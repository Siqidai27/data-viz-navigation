<html>
	<head>
		<meta charset="utf-8">
		<title>Navigation system using d3</title>
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/foundation-icons/3.0/foundation-icons.min.css">
		<script src="https://d3js.org/d3.v4.min.js"></script>
		<script src="http://d3js.org/topojson.v2.min.js"></script>
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
		<script src="fisheye.js"></script>
	</head>
	<style>

		.roads {
		  	fill: none;
		  	stroke-linejoin: round;
		  	stroke-linecap: round;
		}

		.major-highway { stroke: #525252; stroke-width: .5px; }
		.secondary-highway { stroke: #737373; stroke-width: .5px;}
		.road { stroke: #bdbdbd; stroke-width: .5px;}
		.beltway { stroke: #737373; stroke-width: .5px;}
		.ferry-route { stroke: #4393c3; stroke-width: .5px; }
	</style>
	<body>
		<div class="heading">
			<h1> <div class="yellow">Navigation</div> </h1>
			<div class="intro">
				<h3 class="yellow">Introduction</h3>
				<p>
					<a href=>[ fact check! ]</a>. This webpage illuminates these economic changes through visual representations.</p>
				<i class="fi-arrow-down small"></i>
			</div>

		</div>

	<script>
	var width = 960,height = 600;

	var svg = d3.select("body").append("svg")
	    .attr("width", width)
	    .attr("height", height);
	var transform = d3.zoomIdentity;

	var projection = d3.geoAlbersUsa()
		.scale(1100)
		.translate([width / 2, height / 2]);
	var rawData

	d3.json("data/usroads.json", function(error, usroads) {
		if (error) throw error;
		rawData = usroads;
		showMap();
	})

	function showMap(){
		var path = d3.geoPath()
		    .projection(projection);
		var path2 = d3.geoPath();

		svg.call(d3.zoom()
	    .scaleExtent([1/2, 16])
	    .on("zoom", zoomed));

		function zoomed() { g.attr("transform", d3.event.transform); }

		function dragged(d) { d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y); }

		var g = svg.append("g");
		var rounder = d3.format(".2f")
		var usaData = topojson.feature(rawData, rawData.objects.usa).features
		var roadsData = topojson.feature(rawData, rawData.objects.roads).features
		var usa = g.append("g")
		.selectAll("path")
		    .data(usaData)
		.enter().append("path")
		    .attr("d", path)
		 	.style("fill","none")
		  	.style("stroke","#252525")
		  	.style("stroke-width",1);

		var roads = g.append("g")
		.selectAll("path")
		 	.data(roadsData)
		.enter().append("path")
      		.attr("d", path)
		    .attr("class",function(d) { return "roads " + d.properties.type.toLowerCase().split(' ').join('-'); });

		// var testPath = topojson.feature(rawData, rawData.objects.roads).features[5]
		// console.log((testPath))
		// g.append("path")
		// .attr("d", path(testPath))
		// .style("fill","none")
		// .style("stroke","blue")
		// .style("stroke-width", 5)

		var data = topojson.feature(rawData, rawData.objects.roads).features;

		// var startN = [];
		// data.forEach(function(d){
		// 	if (d.geometry.type == "LineString"){
		// 		startN.push(d.geometry.coordinates[0])
		// 	}
		// 	if (d.geometry.type == "MultiLineString"){
		// 		for (i=0; i<d.geometry.coordinates.length; i++){
		// 			startN.push(d.geometry.coordinates[i][0])
		// 		}
		// 	}
		// })
		// // console.log(startN)
		var nodes = [];
		data.forEach(function(d){
			if (d.geometry.type == "LineString"){
				var dist = 0;
				for (j=0; j<d.geometry.coordinates.length-1; j++) {
					var s0 = d.geometry.coordinates[j]
					var s1 = d.geometry.coordinates[j+1]
					dist += Math.sqrt((s1[0]-s0[0])*(s1[0]-s0[0]) + (s1[1]-s0[1])*(s1[1]-s0[1]))
				}
				nodes.push({start:d.geometry.coordinates[0], end:d.geometry.coordinates[d.geometry.coordinates.length-1], distance: dist})
			}
			if (d.geometry.type == "MultiLineString"){
				var dist = 0;
				for (i=0; i<d.geometry.coordinates.length; i++) {
					var temp = d.geometry.coordinates[i];
					// console.log(temp)
					for (j=0; j<temp.length-1; j++) {
						var s0 = temp[j]
						var s1 = temp[j+1]
						dist += Math.sqrt((s1[0]-s0[0])*(s1[0]-s0[0]) + (s1[1]-s0[1])*(s1[1]-s0[1]))

					}
					nodes.push({start:temp[0], end:temp[temp.length-1], distance: dist})
				}
			}
		})
		// console.log(nodes)
		var nodesArray = [];
		nodes.forEach(function(d){
			nodesArray.push(d.start)
			nodesArray.push(d.end)
		})
		// console.log(nodesArray)


		// function convertArrayOfObjectsToCSV(args) {
	    //     var result, ctr, keys, columnDelimiter, lineDelimiter, data;
		//
	    //     data = args.data || null;
	    //     if (data == null || !data.length) {
	    //         return null;
	    //     }
		//
	    //     columnDelimiter = args.columnDelimiter || ',';
	    //     lineDelimiter = args.lineDelimiter || '\n';
		//
	    //     keys = Object.keys(data[0]);
		//
	    //     result = '';
	    //     result += keys.join(columnDelimiter);
	    //     result += lineDelimiter;
		//
	    //     data.forEach(function(item) {
	    //         ctr = 0;
	    //         keys.forEach(function(key) {
	    //             if (ctr > 0) result += columnDelimiter;
		//
	    //             result += item[key];
	    //             ctr++;
	    //         });
	    //         result += lineDelimiter;
	    //     });
		//
	    //     return result;
	    // }
		// function downloadCSV(args) {
	    //     var data, filename, link;
	    //     var csv = convertArrayOfObjectsToCSV({
	    //         data: nodesArray
	    //     });
	    //     if (csv == null) return;
		//
	    //     filename = args.filename || 'export.csv';
		//
	    //     if (!csv.match(/^data:text\/csv/i)) {
	    //         csv = 'data:text/csv;charset=utf-8,' + csv;
	    //     }
	    //     data = encodeURI(csv);
		//
	    //     link = document.createElement('a');
	    //     link.setAttribute('href', data);
	    //     link.setAttribute('download', filename);
	    //     link.click();
	    // }
		// downloadCSV(nodesArray)
		var nodesCoor
		var result
		var coor
		d3.csv("data/nodesCoor.csv", function(error, data){
			nodesCoor=data;
			var coor=[]
			var coors=[]
			result=[]
			var count=0;
			for (i=0; i<nodesCoor.length; i++){
				coor.push([data[i][0],data[i][1]])
				result.push({name:""+count,coordinates:coor[i]})
				count++
			}
			// console.log(coor)
			var circles = g.append("g").selectAll("circle").data(coor);
			circles.exit().remove();
			circles.enter().append("circle")
			.attr("r", 1)
			.merge(circles)
			.attr("cx", function(d) {
				if (projection(d)!=null){
					return projection(d)[0];
				}
			})
			.attr("cy", function(d) {
				if (projection(d)!=null){
					return projection(d)[1];
				}
			})
			.style("fill", "red");

			// console.log(result[0].coordinates[0])
			// console.log(nodes[0].start[0])
			// console.log(nodes)
			// for (i=0; i<nodes.length; i++){
			// 	for (j=0; j<result.length; j++){
			// 		if (nodes[i].start[0]==result[j].coordinates[0] &&
			// 			nodes[i].start[1]==result[j].coordinates[1]){
			//
			// 			}
			// 	}
			// }
			var dij=[]
			for (i=0; i<result.length; i++){
				var name = result[i].name
				var coordinates = result[i].coordinates
				for (j=0; j<nodes.length; j++){
					var start = nodes[j].start
					var end = nodes[j].end
					var value = []
					// console.log(start)
					// console.log(end)
					// console.log(coordinates)
					if (Math.abs(start[0]-coordinates[0])<0.0000001 && Math.abs(start[1]-coordinates[1])<0.0000001){
						value.push({node:end, distance:nodes[j].distance})
						// console.log(value)
					}
				}
				dij.push({name:name, value: value})
			}
			// var temp = result[6]
			// for (j=0; j<nodes.length; j++) {
			// 	var start = nodes[j].start
			// 	var end = nodes[j].end
			// 	var value = []
			// 	if (start[0]==temp.coordinates[0] && start[1]==temp.coordinates[1]){
			// 		value.push({node:end})
			// 		console.log(value)
			// 	}
			// }
			console.log(dij)
		})



		// var fisheye = d3.fisheye.circular()
		// 	.radius(200)
		// 	.distortion(2);
		//
		// svg.on("mousemove", function() {
		// 	// var center = d3.mouse(this);
		// 	// fisheye.focus(projection.invert([center[0],center[1]]));
		// 	fisheye.focus(d3.mouse(this));
		// 	var paths = d3.selectAll("path")
		//
		// 	paths.attr("transform", function(d) {
		// 		var b = d.geometry.coordinates;
		// 		// console.log(b)
		// 		var c = b.map(function(e){
		// 			var f = {x:e[0], y:e[1]};
		// 			return fisheye(f);
		// 		})
			// 	var g=[]
			// 	for (i=0; i<c.length; i++) {
			// 		g.push(([c[i].x, c[i].y]))
			//
			// 	}
			// 	var p = {type: d.geometry.type, coordinates: g}
			// 	// console.log(path(p))
			// 	// return path(p)
		    // })

			// circles.enter()
			// .attr("cx", function(d){
			// 	d.fisheye = d.geometry.coordinates.map(function(e){
			// 		var f = {x:e[0], y:e[1]};
			// 		return fisheye(f);
			// 		return d.fisheye.x})
			// .attr("cy", function(d){return d.fisheye.y})
			// .attr("r", function(d){return d.fisheye.z*0.5})


		// });

	}

	</script>


	</body>
</html>
